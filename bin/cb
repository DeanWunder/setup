#!/usr/bin/python3
import os
import re
import subprocess

# Get the branch for a particular repo.
def get_branch(repo):
    return command('git branch --show-current'.split(' '), dir=repo)

# Get the hash of the latest commit on current branch for a particular repo.
def get_hash(repo):
    return command('git rev-parse HEAD'.split(' '), dir=repo)

# Get a list of checked out branches of repos which exist in:
# ~/git/ and also ~/git/<project>/vendor/finao/
def get_repo_state():
    user = os.getlogin()
    project = command('get_project_from_current_directory')
    if not project:
        project = 'prime'
    home = '/home/' + user
    vendor_finao = home + '/git/' + project + '/vendor/finao'
    pkg_repos = os.listdir(vendor_finao)

    # Turn package names into full paths.
    pkg_paths = list(map(
        lambda p: home + '/git/' + p,
        pkg_repos
    ))

    # Remove vendor packages that don't exists in ~/git/ as a repo.
    pkg_repos = list(filter(os.path.exists, pkg_paths))
    
    # Get branch names for each package repo.
    branches = list(map(get_branch, pkg_repos))
    hashes = list(map(get_hash, pkg_repos))
    infos = list(map(
        lambda p: {'branch': p[0], 'hash': p[1]},
        list(zip(branches, hashes))
    ))
    return dict(zip(pkg_repos, infos))

# Run a system command
def command(cmd, dir='.', stderr=None):
    return subprocess.check_output(
        cmd,
        cwd=dir,
        stderr=stderr
    ).decode('utf-8').rstrip('\n')

# Checkout a branch and pull for a particular repo.
def checkout_branch(repo_path, branch):
    p0 = subprocess.Popen(
        ['git', 'stash'],
        stdout=subprocess.DEVNULL,
        cwd=repo_path
    )
    p0.wait()
    p1 = subprocess.Popen(
        ['gsw', branch],
        stdout=subprocess.DEVNULL,
        cwd=repo_path
    )
    p1.wait()
    return subprocess.Popen(
        ['git', 'pull', 'origin', branch],
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,
        cwd=repo_path
    )

def line_to_popen(line):
    user = os.getlogin()
    home = '/home/' + user
    repo_basename = re.search(r'"finao/(.*)":', line).group(1)
    repo = home + '/git/' + repo_basename
    version = re.search(r':.*"(.*)"', line).group(1)

    custom_branch = re.search(r'^dev-(.*-\d+) as .*$', version)
    if version == 'dev-master' or re.search(r'^[\^\d\.]*$', version):
        return checkout_branch(repo, 'master')
    elif version == 'dev-bidfood' and repo_basename == 'inductiondoc':
        return checkout_branch(repo, 'bidfood')
    elif version == 'dev-dlp' and repo_basename == 'links':
        return checkout_branch(repo, 'dlp')
    elif version == 'dev-swd' and repo_basename == 'links':
        return checkout_branch(repo, 'swd')
    elif version == 'dev-watertight' and repo_basename == 'support':
        return checkout_branch(repo, 'watertight')
    elif custom_branch:
        return checkout_branch(repo, custom_branch.group(1))

if __name__ == '__main__':
    user = os.getlogin()
    home = '/home/' + user
    project = command('get_project_from_current_directory')
    composer_json = home + '/git/' + project + '/composer.json'
    # Read data from composer.json
    with open(composer_json, 'r') as f:
        json_lines = f.readlines()

    state = get_repo_state()

    popens = list(map(
        line_to_popen,
        list(filter(
            lambda l: re.search(r'"finao/.*":', l) and not 'vaporize' in l,
            json_lines
        ))
    ))

    # Block until all git pulls are completed.
    for popen in popens:
        if popen:
            popen.wait()
    
    # Print out the current branch for all repos.
    print(command('lb'))
